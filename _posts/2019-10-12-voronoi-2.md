---
title: A Quest for Voronoi Diagrams - 2. Fortune's Implementation
type: post
tags: [ voronoi, algorithm, tessellation, game ]
comment: true
date: 2019-10-12 22:40:32 +0200
---

In the [first article about my quest for Voronoi diagrams][voronoi-1] I
ranted a bit about how everybody around seems to be talking about
Fortune's algorithm without having bothered to read Steven Fortune's
paper from 1987 [A sweepline algorithm for Voronoi
diagrams][fortune-springer].

Fortune also implemented the algorithm described in the paper as a C
program. I would say it does what's written on the can but, buy today's
standards, it has... space for improvement :)

I'll put some notes below about what I understood of it... I hope it can
be useful.

The code can be found in Fortune's homepage ([here a link to the copy
at the Internet Archive][sjf-archive-org]).

## Adherence To The Paper

The program is largely adherent to the paper, with some caveats:

- the priority queue is implemented in a "split arrangement" where sites
  and vertices are kept separated (actually, only the latter ones end up
  in a real priority queue). This is an implementation trick that, to
  any extent, is totally equivalent to having a single queue;

- the list of region/branch/region/branch/.../region is implemented as a
  doubly-linked list of branches only, where branches carry around also
  information about their associated regions. From a representation
  point of view it's equivalent, but...

- the doubly-linked list for branches  *cannot* be used for a binary
  search of the "right" region, which somehow defies the complexity
  analysis, although Fortune also implements a hash-based indexing of
  the doubly-linked list that improves performance (I have no idea about
  the asymptotic complexity though).

- branches of an edge are not represented as explained in the paper,
  with in a different way that takes some time to grasp.

## Data Structures

Both *sites* and *vertices* are represented by a data structure with the
associated type `Site`. This can be confusing while reading the code
without some prior knowledge, so it takes a bit to get used to. There's
a reason for that, though: the algorithm sweeps a line that might hit
either a *site* or a *vertex*, hence it makes sense to have the same
representation (in a object-oriented language they would probably be two
classed derived from a common ancestor, but it's C baby).

The struct associated to type `Edge` represents an... edge. This
contains a line, represented by three parameters `a`, `b` and `c`
defining the equation:

    a * x + b * y = c

It also contains pointers to two *sites* (because each edge is the line
that divides the plane in half, each containing the points closer to
either *site*) and can also optionally support two pointers to the
endoints of the edge (which would be *vertices*). Anyway, edges might
even have one single *vertex*, or none at all.

It must be noted that, the the `Edge` representation, the first pointer
to a `Site` is *always* the bottomest one (i.e. the one with lower y),
while the top one is the second. This gives a *natural* positioninig of
the sites with respect to the edge, i.e. the bottom `Site` is always the
*left* one.

The last structure of interest, associated to type `Halfedge`, is a
representation of an `Edge` but with a specific *direction*. In
particular, each `Edge` has two associated `Halfedges`, one *left* with
the same orientation as the `Edge` itself (bottom `Site` is on the left)
and the other with the opposite one.

This peculiar representation of the `Halfedge` is what allows, to some
extent, to have an ordering on the x axis of the different edges, as
required by the algorithm. Additionally, although not explicit in the
data structure, the way this representation is used sort-of corresponds
to the two hyperbola parts that pass through the *site* that is above
the bisector.

## The Right Region - in V(\*)

As already indicated in [the first article][voronoi-1], a key part of
Fortune's *original* algorithm is finding the *most interested region*
by the introduction of a new *site*.

The algorithm's description suggests to consider the different sections
of hyperbola and how they intersect to find this out, although this is
arguably a bit vague.

At the high level, when a new *site* is found by the sweep line, the
list of all `Halfedge`s found so far is iterated to find the closest one
that immediately on the left of this new *site*. This is done by function
`ELleftbnd` in file `edgelist.c`.

Based on the new *site*'s position, the function takes a first guess at
where the most realistic candidate might be in the linked list (this is
done using a sort of "hash-cache" pointing to different positions in the
doubly-linked list of `Halfedge`s), then moves left or right depending
on whether the specific `Halfedge` is on the right of the new *site* or
not.

The key to moving or stopping is function `right_of` implemented in
`geometry.c`. I initially struggled a bit on this, because its naming of
a few variables can be misleading (in particular, the `above` variable
is super-confusing for me), but ultimately I think that the
implementation is correct.

It has to be kept in mind that all operations in the algorithm are
thought to happen in the transformed space, hence they take into account
the Voronoi diagram in the transformed space instead of the original
diagram. Thanks to the \* transformation introduced by Fortune, all but
the *site*s are pushed up in the plane, so when comparing the `y`
coordinate of two points this has to be taken into account.

The code makes a distinction based on whether the edge line is more
"vertical" (i.e. `a == 1.0`) or "horizontal" (i.e. `b == 1.0`). The
latter case establishes whether the new *site* is above a `Halfedge`
like this:

    else  /*** e->b == 1.0 ***/
        {
        yl = e->c - e->a * p->x ;
        t1 = p->y - yl ;
        t2 = p->x - topsite->coord.x ;
        t3 = yl - topsite->coord.y ;
        above = ((t1*t1) > ((t2 * t2) + (t3 * t3))) ;
        }

It's easy to spot Pythagoras's theorem on the right hand side here: the
sum of those squares amount to the square of the distance from the *top*
site defining the `Edge`'s line from the point on this `Edge` that is
immediately below the new *site*'s position (i.e. the point on the
`Edge` with the same `x` coordinate). This is compared against the
square of the distance from the new *site* from that very point. Why
compare these distances to establish whether the new *site* lies *above*
the `Halfedge`?

The answer can be found easily when thinking in the transformed space.
Here, all *site*s keep their original position (including the `y`
coordinate), while other points are generally moved above by the
distance they have from their closest *site*.

When we consider the points on a `Halfedge`, the basic assumption is
that considering it means that we are considering it on the boundary
between the `topsite` and the corresponding bottom one. Hence, the
specific point will be pushed higher by the distance it has from
`topsite`.

Hence, in the transformed space, the new *site* will lie above the
corresponding point at the same `x` in the `Halfedge` if, and only if,
the inequality of the implementation applies. 

This also allows us better understanding how this helps classifying the
*site* as lying `right_of` of the `Halfedge`. With reference to the
following picture, consider three possible new candidate *sites*, all at
the same `x` coordinate:

- *site* `X` lies *below* (i.e. `above` is false) according to the
  formula in the implementation, even if it seems to lie above the
  bisector. It is clear that X is much closer to `Y'` than the top
  *site* `T`

- *site* `Y` is exactly at the same distance from `Y'` as it is `T`

- *site* `Z` lies *above* instead

    FIXME INSERT PICTURE HERE!!!


Points `X'`, `Y'` and `Z'` represent the intersection between the
original `Edge` (i.e. bisector between `T` and `B`) and the bisectors
between `T` and `X`, `Y` and `Z` respectively. It's easy to see that
they lie respectively right of, in the `x` place, or left of the new
*site* they correspond to. Hence, `right_of` will eventually tell us
whether the new *site* would lie to the right of the intersection
between the starting bisector (between `T` and `B`) and the hypothetical
bisector between the new *site* and `T`.


## Wrap Up

Fortune's original implementation helps shed a light on the very
high-level description of the algorithm provided in the original article
from 1987 [A sweepline algorithm for Voronoi
diagrams][fortune-springer], which is also - arguably - the *only*
one that can be called Fortune's algorithm (at least when linking that
paper!).

The implementation is somehow optimized and not really easy to follow,
because optimizations (like memory management) are intermixed to enhance
performance. Still it's been very instructive to read it and hopefully
understand it as well.


[CodingGame]: https://www.codingame.com/
[voronoi-wikipedia]: https://en.wikipedia.org/wiki/Voronoi_diagram
[Perl]: https://www.perl.org/
[fortune-wikipedia]: https://en.wikipedia.org/w/index.php?title=Fortune%27s_algorithm&oldid=919888039
[fortune-springer]: https://link.springer.com/article/10.1007%2FBF01840357
[wong-muller]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.83.5571
[netlib-voronoi]: https://www.netlib.org/voronoi/
[sjf-archive-org]: https://web.archive.org/web/20181018224943/http://ect.bell-labs.com/who/sjf/
[voronoi-1]: {{ '/2019/10/12/voronoi-1/' | prepend: site.baseurl | prepend: site.url }}
