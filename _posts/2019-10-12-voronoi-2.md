---
title: A Quest for Voronoi Diagrams - 2. Fortune's Implementation
type: post
tags: [ voronoi, algorithm, tessellation, game ]
comment: true
date: 2019-10-12 22:40:32 +0200
---

In the [first article about my quest for Voronoi diagrams][voronoi-1] I
ranted a bit about how everybody around seems to be talking about
Fortune's algorithm without having bothered to read Steven Fortune's
paper from 1987 [A sweepline algorithm for Voronoi
diagrams][fortune-springer].

Fortune also implemented the algorithm described in the paper as a C
program. I would say it does what's written on the can but, buy today's
standards, it has... space for improvement :)

I'll put some notes below about what I understood of it... and how I
consider it somehow bugged.

The code can be found in Fortune's homepage ([here a link to the copy
at the Internet Archive][sjf-archive-org]).

## Adherence To The Paper

The program is largely adherent to the paper, with some caveats:

- the priority queue is implemented in a "split arrangement" where sites
  and vertices are kept separated (actually, only the latter ones end up
  in a real priority queue). This is an implementation trick that, to
  any extent, is totally equivalent to having a single queue;

- the list of region/branch/region/branch/.../region is implemented as a
  doubly-linked list of branches only, where branches carry around also
  information about their associated regions. From a representation
  point of view it's equivalent, but...

- the doubly-linked list for branches  *cannot* be used for a binary
  search of the "right" region, which somehow defies the complexity
  analysis, although Fortune also implements a hash-based indexing of
  the doubly-linked list that improves performance (I have no idea about
  the asymptotic complexity though).

- branches of an edge are not represented as explained in the paper,
  with in a different way that takes some time to grasp.

## Data Structures

Both *sites* and *vertices* are represented by a data structure with the
associated type `Site`. This can be confusing while reading the code
without some prior knowledge, so it takes a bit to get used to. There's
a reason for that, though: the algorithm sweeps a line that might hit
either a *site* or a *vertex*, hence it makes sense to have the same
representation (in a object-oriented language they would probably be two
classed derived from a common ancestor, but it's C baby).

The struct associated to type `Edge` represents an... edge. This
contains a line, represented by three parameters `a`, `b` and `c`
defining the equation:

    a * x + b * y = c

It also contains pointers to two *sites* (because each edge is the line
that divides the plane in half, each containing the points closer to
either *site*) and can also optionally support two pointers to the
endoints of the edge (which would be *vertices*). Anyway, edges might
even have one single *vertex*, or none at all.

It must be noted that, the the `Edge` representation, the first pointer
to a `Site` is *always* the bottomest one (i.e. the one with lower y),
while the top one is the second. This gives a *natural* positioninig of
the sites with respect to the edge, i.e. the bottom `Site` is always the
*left* one.

The last structure of interest, associated to type `Halfedge`, is a
representation of an `Edge` but with a specific *direction*. In
particular, each `Edge` has two associated `Halfedges`, one *left* with
the same orientation as the `Edge` itself (bottom `Site` is on the left)
and the other with the opposite one.

This peculiar representation of the `Halfedge` is what allows, to some
extent, to have an ordering on the x axis of the different edges, as
required by the algorithm.

## A Bug?

As already indicated in [the first article][voronoi-1], a key part of
Fortune's *original* algorithm is finding the region in the already
built diagram where a new *site* would belong if it were a regular
point (and not a *site*).

Intuitively, this is needed because the new *site* will change the
equilibrium and it will *most probably* have an edge in common with the
closest site found so far (this is a consequence of sweeping the line).
Maybe always, I should read the article again for this :)

Anyway, that site/region has to be found. This is where I struggle to
understand the implementation.

### High level procedure

At the high level, when a new *site* is found by the sweep line, the
list of all `Halfedge`s found so far is iterated to find the closest one
that immediately on the left of this new *site*. This is done by function
`ELleftbnd` in file `edgelist.c`.

Based on the new *site*'s position, the function takes a first guess at
where the most realistic candidate might be in the linked list (this is
done using a sort of "hash-cache" pointing to different positions in the
doubly-linked list of `Halfedge`s), then moves left or right depending
on whether the specific `Halfedge` is on the right of the new *site* or
not.

The key to moving or stopping is function `right_of` implemented in
`geometry.c`. This is where I find issues to be honest, because it seems
to me that it does not really always tell the truth. As an example,
consider the following three sites, ordered from bottom to top:

    S0 = (9, 2)
    S1 = (11, 6)
    S2 = (6, 7)

The first two sites are analyzed first and the following line describes
the bisector:

    site (0) at 9.000000 2.000000
    site (1) at 11.000000 6.000000
    line(0) 0.5x+1y=9, bisecting 0 1

It is easy to see that site S2 is *above* of this line, i.e. on the same
side as S1 and on the opposite side of S0. In fact:

    x = S0x = 9  =>  y = 9 - 0.5 * 9 = 4.5 > 2 = S0y

    x = S1x = 11 =>  y = 9 - 0.5 * 11 = 3.5 < 6 = S1y

    x = S2x = 6  =>  y = 9 - 0.5 * 6 = 6 < 7 = S2y

And yet, Fortune's implementation first chooses to calculate the
bisector of the new *site* S2 against S0:

    site (2) at 6.000000 7.000000
    line(1) -0.6x+1y=0, bisecting 0 2
    circle through left=2 right=1 bottom=0
    vertex(0) at 8.181818 4.909091
    line(2) 1x+-0.2y=7.2, bisecting 1 2
    e 1 -1 0
    e 2 0 -1
    e 0 0 -1

Of course in this case it does not yield no issue, because even
bisecting with S1 first would yield the same final result. Still, it
might be that a bug is only waiting to be triggered!


## Wrap Up

Fortune's original implementation helps shed a light on the very
high-level description of the algorithm provided in the original article
from 1987 [A sweepline algorithm for Voronoi
diagrams][fortune-springer], which is also - arguably - the *only*
one that can be called Fortune's algorithm (at least when linking that
paper!).

The implementation is somehow optimized and not really easy to follow,
because optimizations (like memory management) are intermixed to enhance
performance. Still it's been instructive although I'm still wondering
whether I found a but in it after more than 30 years. Go figure.



[CodingGame]: https://www.codingame.com/
[voronoi-wikipedia]: https://en.wikipedia.org/wiki/Voronoi_diagram
[Perl]: https://www.perl.org/
[fortune-wikipedia]: https://en.wikipedia.org/w/index.php?title=Fortune%27s_algorithm&oldid=919888039
[fortune-springer]: https://link.springer.com/article/10.1007%2FBF01840357
[wong-muller]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.83.5571
[netlib-voronoi]: https://www.netlib.org/voronoi/
[sjf-archive-org]: https://web.archive.org/web/20181018224943/http://ect.bell-labs.com/who/sjf/
[voronoi-1]: {{ '/2019/10/12/voronoi-1/' | prepend: site.baseurl | prepend: site.url }}
