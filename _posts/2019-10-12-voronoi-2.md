---
title: A Quest for Voronoi Diagrams - 2. Fortune's Implementation
type: post
tags: [ voronoi, algorithm, tessellation, game ]
comment: true
date: 2019-10-12 22:40:32 +0200
---

In the [first article about my quest for Voronoi diagrams][voronoi-1] I
ranted a bit about how everybody around seems to be talking about
Fortune's algorithm without having bothered to read Steven Fortune's
paper from 1987 [A sweepline algorithm for Voronoi
diagrams][fortune-springer].

Fortune also implemented the algorithm described in the paper as a C
program. I would say it does what's written on the can but, buy today's
standards, it has... space for improvement :)

I'll put some notes below about what I understood of it... I hope it can
be useful.

The code can be found in Fortune's homepage ([here a link to the copy
at the Internet Archive][sjf-archive-org]).

## Adherence To The Paper

The program is largely adherent to the paper, with some caveats:

- the priority queue is implemented in a "split arrangement" where sites
  and vertices are kept separated (actually, only the latter ones end up
  in a real priority queue). This is an implementation trick that, to
  any extent, is totally equivalent to having a single queue;

- the list of region/branch/region/branch/.../region is implemented as a
  doubly-linked list of branches only, where branches carry around also
  information about their associated regions. From a representation
  point of view it's equivalent, but...

- the doubly-linked list for branches  *cannot* be used for a binary
  search of the "right" region, which somehow defies the complexity
  analysis, although Fortune also implements a hash-based indexing of
  the doubly-linked list that improves performance (I have no idea about
  the asymptotic complexity though).


## Data Structures

Both *sites* and *vertices* are represented by a data structure with the
associated type `Site`. This can be confusing while reading the code
without some prior knowledge, so it takes a bit to get used to. There's
a reason for that, though: the algorithm sweeps a line that might hit
either a *site* or a *vertex*, hence it makes sense to have the same
representation (in a object-oriented language they would probably be two
classed derived from a common ancestor, but it's C baby).

The struct associated to type `Edge` represents an... edge. This
contains a line, represented by three parameters `a`, `b` and `c`
defining the equation:

    a * x + b * y = c

As a matter of fact, depending on their respective size, the equation
above is normalized so that either `a` or `b` is set to `1`. This is a
minor detail though, all three parameters are kept anyway.

It also contains pointers to two *sites*, representing the two *regions*
that result from the splitting of the plane into two halves by the edge
itself. Apart from a `NULL` edge (which somehow represents the split of
an ideal point at infinity and the first site), these *sites* are always
populated, putting the lowest site in the first slot and the highest one
in the second slot, respectively indexed as *left* and *right* (or `le`
and `re` in the implementation). This makes the edge always "go" from
right to left, apart when the edge is exactly vertical in which case it
goes from down to up.

An `Edge` can also optionally point to two *vertices*. Depending on the
specific arrangement of *sites* and the phase of the algorithm, these
slots might be populated or left empty.

The last structure of interest is `Halfedge`, associated to the `C`
branches in the algorithm, i.e. the two sections of the hyperbola arc
that are divided by the *site*. It's beneficial to think of these to
parts as going in the respective direction, i.e. the *left* half
(marked with `le`) goes left and the *right* part (marked with `re`)
goes right.

## The Right Region - in V(\*)

As already indicated in [the first article][voronoi-1], a key part of
Fortune's *original* algorithm is finding the *most interested region*
by the introduction of a new *site*.

The algorithm's description suggests to consider the different sections
of hyperbola and how they intersect to find this out, although this is
arguably a bit vague. Or, maybe, it's explained well in the mathematical
section but I wasn't too sharp in understanding it immediately.

At the high level, when a new *site* is found by the sweep line, the
list of all `Halfedge`s found so far is iterated to find the closest one
that immediately on the left of this new *site*. This is done by function
`ELleftbnd` in file `edgelist.c`. It should ideally be a binary search,
as a matter of fact it's a kind-of linear search optimized with a good
guess on the best *entry point* in the list, via a hash-like mechanism.

Based on the new *site*'s position, the function takes a first guess at
where the most realistic candidate might be in the linked list (this is
done using a sort of "hash-cache" pointing to different positions in the
doubly-linked list of `Halfedge`s), then moves left or right depending
on whether the specific `Halfedge` is on the right of the new *site* or
not.

The key to moving or stopping is function `right_of` implemented in
`geometry.c`. I initially struggled a bit on this, because its naming of
a few variables can be misleading (in particular, the `above` variable
is super-confusing for me).

It has to be kept in mind that all operations in the algorithm are
thought to happen in the transformed space, hence they take into account
the Voronoi diagram in the transformed space instead of the original
diagram. Thanks to the \* transformation introduced by Fortune, all but
the *site*s are pushed up in the plane, so when comparing the `y`
coordinate of two points this has to be taken into account.

The code makes a distinction based on whether the edge line is more
"vertical" (i.e. `a == 1.0`) or "horizontal" (i.e. `b == 1.0`) but,
apart from a technical detail regarding totally vertical lines, the two
are equivalent. The latter case establishes whether the new *site* is
above a `Halfedge` like this:

~~~~
else  /*** e->b == 1.0 ***/
    {
    yl = e->c - e->a * p->x ;
    t1 = p->y - yl ;
    t2 = p->x - topsite->coord.x ;
    t3 = yl - topsite->coord.y ;
    above = ((t1*t1) > ((t2 * t2) + (t3 * t3))) ;
    }
~~~~

It's easy to spot Pythagoras's theorem on the right hand side here: the
sum of those squares amount to the square of the distance from the *top*
site defining the `Edge`'s line from the point on this `Edge` that is
immediately below the new *site*'s position (i.e. the point on the
`Edge` with the same `x` coordinate). This is compared against the
square of the distance from the new *site* from that very point. Why
compare these distances to establish whether the new *site* lies *above*
the `Halfedge`?

The answer can be found easily when thinking in the transformed space.
Here, all *site*s keep their original position (including the `y`
coordinate), while other points are generally moved above by the
distance they have from their closest *site*.

When we consider the points on a `Halfedge`, we have to keep in mind
that they are the boundary between the *topsite* and the corresponding
*bottomsite*. Hence, in the transformed space the whole line is pushed
above exactly by the distance each point has from the top or bottom
site, including the point exactly below the new *site*.

Hence, in the transformed space, the new *site* will lie above the
corresponding point at the same `x` in the `Halfedge` if, and only if,
the inequality of the implementation applies. As an example, consider
the following picture.

![Voronoi]({{ '/assets/images/XYZV-linear.png' | prepend: site.baseurl | prepend: site.url }})

Potential *sites* `X`, `Y` and `Z` are all located at the same `x`
coordinate, corresponding to point `V` on the bisector between `A` and
`B`. In particular, `Y` is distant from `V` exactly as both `B` and `A`
are, so you can think of `Y` also as the point where `V` ends up after
being transformed by Fortune's map `*`.

Although all the three potential *sites* appear to be above `V` in the
linear space, they are not in the transformed space: `X` is below, `Y`
is (by construction) in the exact same spot, and only `Z` is above. This
is the kind of *above* that the code above calculates.

This boolean `above` condition is eventually used to establish if the
new *site* is `right_of` the specific `Halfedge`, as this is the
returned value:

~~~~
return (el->ELpm == le ? above : !above) ;
~~~~

The initial condition `el->ELpm` indicates whether it is a *left*
`Halfedge` (the C- part in the algorithm's description inside the
article) or a *right* one. Assuming we are dealing with a *left* one,
being *above* also amounts to being on the *right*. This can be easily
understood by looking at the following picture.

![Voronoi]({{ '/assets/images/XYZ-linear.png' | prepend: site.baseurl | prepend: site.url }})

The blue lines represent the bisectors between potential sites `X`, `Y`
and `Z` with site `A`, the red lines with site `B`. Points `X'`, `Y'`
and `Z'` represent, respectively, where these bisectors cross the
initial bisector between `A` and `B`.

As expected, `Y'` is exactly below `Y` and is the same as point `V` in
the previous picture. Points *above* `Y` (like `Z`) will cross on the
left (hence they will be *on the right*), points *below* (like `X`) will
cross on the right (hence they will be *on the left*). As a result,
being *above* amounts to also being *on the right*. A similar argument
can be construed with a *right* `Halfedge`, but with roles exhanged for
`above`.

It needs not be this difficult to explain though. The following picture
represents a view of the previous one in the space transformed by `*`:
it's evident how *above* means *right of* and *below* means *left of*.

![Voronoi]({{ '/assets/images/XYZ-hyperbolic.png' | prepend: site.baseurl | prepend: site.url }})

The following picture, on the other hand, explains very well how *above*
relates to *left of* and *below* relates to *right of* when considering
a *right* `Halfedge`.

![Voronoi]({{ '/assets/images/XYZ-hyperbolic-right.png' | prepend: site.baseurl | prepend: site.url }})


## Wrap Up

Fortune's original implementation helps shed a light on the very
high-level description of the algorithm provided in the original article
from 1987 [A sweepline algorithm for Voronoi
diagrams][fortune-springer], which is also - arguably - the *only*
one that can be called Fortune's algorithm (at least when linking that
paper!).

The implementation is somehow optimized and not really easy to follow,
because optimizations (like memory management) are intermixed to enhance
performance. Still it's been very instructive to read it and hopefully
understand it as well.


[CodingGame]: https://www.codingame.com/
[voronoi-wikipedia]: https://en.wikipedia.org/wiki/Voronoi_diagram
[Perl]: https://www.perl.org/
[fortune-wikipedia]: https://en.wikipedia.org/w/index.php?title=Fortune%27s_algorithm&oldid=919888039
[fortune-springer]: https://link.springer.com/article/10.1007%2FBF01840357
[wong-muller]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.83.5571
[netlib-voronoi]: https://www.netlib.org/voronoi/
[sjf-archive-org]: https://web.archive.org/web/20181018224943/http://ect.bell-labs.com/who/sjf/
[voronoi-1]: {{ '/2019/10/12/voronoi-1/' | prepend: site.baseurl | prepend: site.url }}
